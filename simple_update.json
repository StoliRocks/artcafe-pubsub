{
  "schemaVersion": "2.2",
  "description": "Update artcafe-pubsub API service - Simple update",
  "parameters": {},
  "mainSteps": [
    {
      "action": "aws:runShellScript",
      "name": "simpleUpdate",
      "inputs": {
        "runCommand": [
          "#!/bin/bash",
          "# Check what services are running",
          "echo \"Checking for artcafe services:\"",
          "systemctl list-units --type=service | grep -E 'artcafe'",
          "",
          "# Create the application directory if it doesn't exist",
          "mkdir -p /opt/artcafe/artcafe-pubsub",
          "",
          "# Create a backup of the current API routes",
          "echo \"Creating backup of current API routes...\"",
          "if [ -d \"/opt/artcafe/artcafe-pubsub/api/routes\" ]; then",
          "    mkdir -p /opt/artcafe/backup",
          "    cp -r /opt/artcafe/artcafe-pubsub/api/routes /opt/artcafe/backup/",
          "    echo \"Backup created in /opt/artcafe/backup/routes\"",
          "else",
          "    echo \"API routes directory not found.\"",
          "fi",
          "",
          "# Update the auth-related files",
          "echo \"Updating auth files...\"",
          "# Create the structure if it doesn't exist",
          "mkdir -p /opt/artcafe/artcafe-pubsub/api/routes",
          "",
          "# Create or update the routes/auth_routes.py file",
          "cat > /opt/artcafe/artcafe-pubsub/api/routes/auth_routes.py << 'EOL'",
          "from fastapi import APIRouter, Depends, HTTPException, status, Request, Response",
          "from fastapi.security import OAuth2PasswordRequestForm",
          "from typing import Optional",
          "from datetime import datetime, timedelta",
          "",
          "from auth.jwt_auth import create_access_token, get_current_user, oauth2_scheme",
          "from auth.tenant_auth import check_tenant_access",
          "from auth.ssh_auth import create_challenge, verify_challenge_response",
          "from infrastructure.challenge_store import ChallengeStore",
          "from models.tenant import TenantModel",
          "",
          "# Initialize the router",
          "router = APIRouter(prefix=\"/api/v1/auth\", tags=[\"Authentication\"])",
          "challenge_store = ChallengeStore()",
          "",
          "# JWT Authentication endpoint",
          "@router.post(\"/token\")",
          "async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends(), request: Request = None):",
          "    \"\"\"",
          "    Authenticates a user and returns a JWT token if credentials are valid.",
          "    Uses OAuth2 password flow. The username is used as the agent ID.",
          "    \"\"\"",
          "    tenant_id = request.headers.get(\"x-tenant-id\")",
          "    if not tenant_id:",
          "        raise HTTPException(",
          "            status_code=status.HTTP_400_BAD_REQUEST,",
          "            detail=\"Tenant ID is required\",",
          "            headers={\"WWW-Authenticate\": \"Bearer\"},",
          "        )",
          "",
          "    # Implement your authentication logic here",
          "    # For this example, we'll accept any credentials and use the username as the agent ID",
          "    agent_id = form_data.username",
          "    ",
          "    # Validate that the agent has access to the tenant",
          "    tenant_access = check_tenant_access(agent_id, tenant_id)",
          "    if not tenant_access:",
          "        raise HTTPException(",
          "            status_code=status.HTTP_403_FORBIDDEN,",
          "            detail=\"Agent does not have access to this tenant\",",
          "            headers={\"WWW-Authenticate\": \"Bearer\"},",
          "        )",
          "",
          "    # Create access token",
          "    access_token_expires = timedelta(minutes=60)",
          "    access_token = create_access_token(",
          "        data={\"sub\": agent_id, \"tenant_id\": tenant_id},",
          "        expires_delta=access_token_expires",
          "    )",
          "",
          "    # Return the token",
          "    return {\"access_token\": access_token, \"token_type\": \"bearer\"}",
          "",
          "",
          "# SSH Key Authentication endpoint - Challenge",
          "@router.post(\"/challenge/{agent_id}\")",
          "async def get_auth_challenge(agent_id: str, request: Request):",
          "    \"\"\"",
          "    Creates and returns a challenge for SSH key authentication.",
          "    \"\"\"",
          "    tenant_id = request.headers.get(\"x-tenant-id\")",
          "    if not tenant_id:",
          "        raise HTTPException(",
          "            status_code=status.HTTP_400_BAD_REQUEST,",
          "            detail=\"Tenant ID is required\",",
          "        )",
          "",
          "    # Validate that the agent has access to the tenant",
          "    tenant_access = check_tenant_access(agent_id, tenant_id)",
          "    if not tenant_access:",
          "        raise HTTPException(",
          "            status_code=status.HTTP_403_FORBIDDEN,",
          "            detail=\"Agent does not have access to this tenant\",",
          "        )",
          "",
          "    # Create a challenge",
          "    challenge = create_challenge(agent_id)",
          "    ",
          "    # Store the challenge",
          "    challenge_store.store_challenge(agent_id, challenge, tenant_id)",
          "    ",
          "    # Return the challenge",
          "    return {\"challenge\": challenge}",
          "",
          "",
          "# SSH Key Authentication endpoint - Verification",
          "@router.post(\"/verify/{agent_id}\")",
          "async def verify_auth_challenge(agent_id: str, signed_data: dict, request: Request):",
          "    \"\"\"",
          "    Verifies a signed challenge for SSH key authentication.",
          "    \"\"\"",
          "    tenant_id = request.headers.get(\"x-tenant-id\")",
          "    if not tenant_id:",
          "        raise HTTPException(",
          "            status_code=status.HTTP_400_BAD_REQUEST,",
          "            detail=\"Tenant ID is required\",",
          "        )",
          "",
          "    # Get the stored challenge",
          "    stored_challenge = challenge_store.get_challenge(agent_id, tenant_id)",
          "    if not stored_challenge:",
          "        raise HTTPException(",
          "            status_code=status.HTTP_400_BAD_REQUEST,",
          "            detail=\"No challenge found or challenge expired\",",
          "        )",
          "",
          "    # Verify the signed challenge",
          "    signature = signed_data.get(\"signature\")",
          "    if not signature:",
          "        raise HTTPException(",
          "            status_code=status.HTTP_400_BAD_REQUEST,",
          "            detail=\"Signature is required\",",
          "        )",
          "",
          "    valid = verify_challenge_response(agent_id, stored_challenge, signature)",
          "    if not valid:",
          "        raise HTTPException(",
          "            status_code=status.HTTP_401_UNAUTHORIZED,",
          "            detail=\"Invalid signature\",",
          "        )",
          "",
          "    # Remove the used challenge",
          "    challenge_store.remove_challenge(agent_id, tenant_id)",
          "",
          "    # Create access token",
          "    access_token_expires = timedelta(days=30)  # Longer token for SSH authenticated agents",
          "    access_token = create_access_token(",
          "        data={\"sub\": agent_id, \"tenant_id\": tenant_id, \"auth_method\": \"ssh_key\"},",
          "        expires_delta=access_token_expires",
          "    )",
          "",
          "    # Return the token",
          "    return {\"access_token\": access_token, \"token_type\": \"bearer\"}",
          "",
          "",
          "# Resend verification code endpoint",
          "@router.post(\"/resend-code\")",
          "async def resend_verification_code(email: str, request: Request):",
          "    \"\"\"",
          "    Resends a verification code to the user's email.",
          "    \"\"\"",
          "    # This would typically connect to your email service or auth provider",
          "    # For now, we'll just simulate success",
          "    return {",
          "        \"message\": f\"Verification code resent to {email}\",",
          "        \"success\": True",
          "    }",
          "",
          "# Refresh token endpoint",
          "@router.post(\"/refresh\")",
          "async def refresh_token(request: Request):",
          "    \"\"\"",
          "    Refreshes a JWT token using a refresh token.",
          "    \"\"\"",
          "    token = request.headers.get(\"Authorization\", \"\").replace(\"Bearer \", \"\")",
          "    if not token:",
          "        raise HTTPException(",
          "            status_code=status.HTTP_401_UNAUTHORIZED,",
          "            detail=\"Invalid token\",",
          "        )",
          "",
          "    # Normally you would validate a refresh token here",
          "    # For now we'll just create a new access token with the same data",
          "    # In production, use a proper refresh token mechanism",
          "    try:",
          "        current_user = get_current_user(token)",
          "        ",
          "        # Create new access token",
          "        access_token_expires = timedelta(minutes=60)",
          "        access_token = create_access_token(",
          "            data={\"sub\": current_user[\"sub\"], \"tenant_id\": current_user[\"tenant_id\"]},",
          "            expires_delta=access_token_expires",
          "        )",
          "        ",
          "        return {\"access_token\": access_token, \"token_type\": \"bearer\"}",
          "    except Exception as e:",
          "        raise HTTPException(",
          "            status_code=status.HTTP_401_UNAUTHORIZED,",
          "            detail=\"Invalid token for refresh\",",
          "            headers={\"WWW-Authenticate\": \"Bearer\"},",
          "        )",
          "EOL",
          "",
          "# Restart the service",
          "echo \"Attempting to restart the artcafe-pubsub service...\"",
          "FOUND=$(systemctl list-units --type=service | grep -E 'artcafe-pubsub' | awk '{print $1}')",
          "if [ -n \"$FOUND\" ]; then",
          "    echo \"Found service: $FOUND, restarting...\"",
          "    systemctl restart $FOUND",
          "    systemctl status $FOUND",
          "else",
          "    echo \"No artcafe-pubsub service found.\"",
          "fi",
          "",
          "echo \"Update completed.\""
        ]
      }
    }
  ]
}